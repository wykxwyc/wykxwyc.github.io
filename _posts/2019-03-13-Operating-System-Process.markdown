---
layout:     post
title:      "操作系统（进程管理）"
subtitle:   "Operating System (process management)"
date:       2019-03-13
author:     "wykxwyc"
header-img: "img/post-bg-operating-system.jpg"
tags:
    - OS
    - C++
---
> 分别考虑两种情形，一种情形是cpu执行一个数据的累加操作，直接得到结果；另一种情形是cpu从内存中读取某个数据，然后再进行某种累加操作。在两种情况下，虽然只相差了从内存中读数据这一个操作，但最后两者相差的时间却非常大。因此我们需要引入进程的概念，让cpu充分忙碌起来。


#### 进程概念
进程是资源分配的基本单位。
进程包括程序代码段，当前活动（通过**程序计数器**和处理器的寄存器内容表示），进程堆栈段（临时数据，函数参数，返回地址，局部变量），数据段（全局变量等）。还可能有堆（继承运行期间动态分配的内存）。

通俗来讲，进程是一段可执行程序加上一系列计算机资源。


#### 进程状态
**新的**：进程正在被创建。
**运行**：指令正在被执行。
**等待**：进程等待某个事件的发生。
**就绪**：进程等待分配处理器。
**终止**：进程完成执行。

* 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
* 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

进程的状态如下图：

![process](/img/in-post/post-operation-system/os_process_status.png)


#### 进程控制块
进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。


#### 进程间通信机制(IPC)
IPC(interprocess communication)有两种基本模式：共享内存和消息传递。

两种通信模型图如下：

![ipc-model](/img/in-post/post-operation-system/os-ipc-model.PNG)

5种通信方式，参考[这里](https://www.cnblogs.com/zgq0/p/8780893.html)：

* 管道
管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。
特点：
它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

* FIFO
FIFO，也称为命名管道，它是一种文件类型。
特点：
FIFO可以在无关的进程之间交换数据，与无名管道不同。
FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

FIFO可以拓展乘客户进程—服务器进程通信的实例。
具体模型如下：

![fifo-model](/img/in-post/post-operation-system/fifo-model.png)

* 消息队列
消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
特点：
消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

```
1 #include <sys/msg.h>
2 // 创建或打开消息队列：成功返回队列ID，失败返回-1
3 int msgget(key_t key, int flag);
4 // 添加消息：成功返回0，失败返回-1
5 int msgsnd(int msqid, const void *ptr, size_t size, int flag);
6 // 读取消息：成功返回消息数据的长度，失败返回-1
7 int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
8 // 控制消息队列：成功返回0，失败返回-1
9 int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

* 信号量
信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
特点
信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
支持信号量组。

* 共享内存
指两个或多个进程共享一个给定的存储区。
特点
共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
因为多个进程可以同时操作，所以需要进行同步。
信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

* 套接字（socket）
最早出现在UNIX系统中，是UNIX系统主要的信息传递方式。
它包括UDP和TCP通信两种方式。

两个基本概念：客户方和服务方。当两个应用之间需要采用SOCKET通信时，首先需要在两个应用之间（可能位于同一台机器，也可能位于不同的机器）建立SOCKET连接。

发起呼叫连接请求的一方为客户方 
在客户方呼叫连接请求之前，它必须知道服务方在哪里。所以需要知道服务方所在机器的IP地址或机器名称，如果客户方和服务方事前有一个约定就好了，这个约定就是PORT（端口号）。也就是说，客户方可以通过服务方所在机器的IP地址或机器名称和端口号唯一的确定方式来呼叫服务方。

接受呼叫连接请求的一方成为服务方。 
在客户方呼叫之前，服务方必须处于侦听状态，侦听是否有客户要求建立连接。一旦接到连接请求，服务方可以根据情况建立或拒绝连接。当客户方的消息到达服务方端口时，会自动触发一个事件（event），服务方只要接管该事件，就可以接受来自客户方的消息了。


#### 线程
单线程与多线程的差别：
![single-thread-and-muti-thread](/img/in-post/post-operation-system/thread-compare.png)

用户级线程和内核级线程的关系。

用户级线程需要内核级线程的支持，用户级线程和内核级线程有三种对应模式：
* 多对一模型
将多个用户级线程对应到一个内核级线程。但这样做时，一个用户级线程阻塞了会导致，那么cpu会认为对应的这个内核级线程阻塞了，转而执行其他内核级线程，从而会导致其他用户级线程不能执行，整个进程阻塞。

* 一对一模型
将每个用户线程映射到一个内核线程。
这种模型比多对一模型的并发性更好，但是每创建一个用户线程就需要一个内核线程，开销大，系统可能无法创建那么多的线程。

* 多对多模型
开发人员可穿件任意多的用户线程，当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。

#### 线程池
